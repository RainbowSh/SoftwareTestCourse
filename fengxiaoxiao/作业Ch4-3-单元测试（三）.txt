什么是测试替身？简要说明5种测试替身的具体实现
1.测试替身：测试替身是出于运行测试这一明确目的而安装代替实际组件的任何对象或组件。
2.哑元对象：哑元对象是作为参数（或参数属性）传递给被测对象但实际上从未使用的占位符对象

private?class?FooDummy?implements?Foo { ????
    public?String?bar()?{?return?null;?} 
} 
public?class?FooCollectionTest { ????
    @Test ????
    public?void?it_should_maintain_a_count() { ???????
        FooCollection?sut?=?new?FooCollection(); ????????
        sut.add(new?FooDummy); ????????
        sut.add(new?FooDummy); ????????
        assertEquals(2,?sut.count()); ????
    } 
}


  测试桩：取代被测对象依赖的实际组件，以便测试可以控制被测对象的间接输入
private?class?FooStub?implements?Foo {
 ????public?String?bar()?{
 ????????return?"baz";
 ????} 
} 
public?class?FooCollectionTest {
 ????@Test
 ????public?void?it_should_return_joined_bars()?{
 ????????FooCollection?sut?=?new?FooCollection();
 ????????sut.add(new?FooStub);
 ????????sut.add(new?FooStub);
 ????????assertEquals("bazbaz",?sut.joined());
 ????}
 }

  测试间谍：作为被测对象间接输出观察点的对象
private?class?ThirdPartyApiSpy?implements?ThirdPartyApi {
 ????public?int?callCount?=?0;
 ????public?boolean?hasMore(Response?previousResponse)?{
 ????????return this.callCount?==?0;
 ????}
 ????public?Response?get(int?page) ????{
 ????????this.callCount++;
 ????????return?new?DummyResponse;
 ????}
 }
 public?class?ApiConsumerTest {
 ????@Test
 ????public?void?it_should_get_all_pages() {
 ????????ThirdPartyApiSpy?spy?=?new?ThirdPartyApiSpy;
 ????????ApiConsumer?sut?=?new?ApiConsumer(spy);
 ????????sut.fetchAll()
 ????????assertEquals(2,?spy.callCount); 
????} 
}

  伪造对象：用相同功能性的可选实现方式取代实际被依赖对象的功能性
private?class?InMemoryUserRepository?implements?UserRepository {
 ????private?UserCollection?users?=?new?UserCollection;
 ????public?User?load(UserIdentifier?identifier) ????{
 ????????if?(!this.users.exists(identifier))?{
 ????????????throw?new?InvalidUserException;
 ????????}
 ????????return?this.users.get(identifier);
 ????}
 ????public?User?find(UserIdentifier?identifier) ????{
 ????????if?(!this.users.exists(identifier))?{
 ????????????return?null;
 ????????}
 ????????return?this.users.get(identifier);
 ????}
 ????public?UserCollection?fetchAll() ????{
 ????????return?this.users;
 ????}
 ????public?boolean?add(User?user) ????{
 ????????return?this.users.add(user);
 ????}
 ????public?boolean?delete(User?user) ????{
 ????????return?this.delete(user.getIdentifier());
 ????}
 ????public?boolean?delete(UserIdentifier?identifier) ????{
 ????????return?this.users.remove(identifier);
 ????}
 }
public?class?CreateUserServiceTest {
 ????@Test
 ????public?void?it_should_save_a_new_user() ????{
 ????????UserRepository?userRepository?=?new?InMemoryUserRepository;
 ????????CreateUserService?sut?=?new?CreateUserService(userRepository);
 ????????sut.createUser(new?UserRequestStub);
 ????????assertEquals(new?UserCollectionStub,?userRepository.fetchAll());
 ????}
 }

  仿制对象：
public?class?FooCollectionTest {
 ????@Test
 ????public?void?it_should_return_joined_bars() ????{
 ????????Foo?fooMock?=?mock(Foo.class);?//?instance
 ????????when(fooMock.bar()).thenReturn("baz",?"qux");?//?behavior
 ????????FooCollection?sut?=?new?FooCollection();
 ????????sut.add(fooMock);
 ????????sut.add(fooMock);
 ????????assertEquals("bazqux",?sut.joined());
 ????????verify(fooMock,?times(2)).bar();?//?verify
 ????}
 }


基于状态的测试和基于交互的测试有什么区别？
基于状态的测试利用被测对象内部状态来验证执行结果的正确性。
  将待测对象及其协作对象的状态与期望的状态进行对比验证
基于交互的测试验证待测对象与其协作对象以期望的方式进行交互。
  是否正确调用了协作对象的方法
  是否使用了正确的参数
  调用顺序是否正确
